//! Reset, Expansion and Clock Control
// CH32V305/307 and CH32F205/207 clock tree structure

// HSI 8MHz
// LSI 40kHz
// max  sysclk 144MHz
// NOTE v203/f203's pll is different from v205/v207/v305/v307

use crate::pac::{EXTEND, RCC};
use crate::time::Hertz;

pub use self::rec::PeripheralREC;

pub mod rec;

/// Configuration of the core clocks
pub struct Config {
    // 3-25MHz HSE OSC
    hse: Option<u32>,
    bypass_hse: bool,
    sysclk: Option<u32>,

    // SYSCLK => [AHB prescaler] => HCLK
    rcc_hclk: Option<u32>,
    // HCLK => [APB1 prescaler] => PCLK1
    rcc_pclk1: Option<u32>,
    // HCLK => [APB2 prescaler] => PCLK2
    rcc_pclk2: Option<u32>,
    // PLLCLK, for SYSCLK, USBCLK, MCO
    pllclk: Option<u32>,
    // HSE -> PREDIV2 -> PLL2MUL
    pll2clk: Option<u32>,
    // HSE -> PREDIV2 -> PLL3MUL
    pll3clk: Option<u32>,
}

/// Extension trait that constrains the `RCC` peripheral
pub trait RccExt {
    /// Constrains the `RCC` peripheral so it plays nicely with the
    /// other abstractions
    fn constrain(self) -> Rcc;
}

impl RccExt for RCC {
    fn constrain(self) -> Rcc {
        Rcc {
            config: Config {
                hse: None,
                bypass_hse: false,
                sysclk: None,
                rcc_hclk: None,
                rcc_pclk1: None,
                rcc_pclk2: None,
                pllclk: None,
                pll2clk: None,
                pll3clk: None,
            },
            rb: self,
        }
    }
}

/// Constrained RCC peripheral
///
/// Generated by calling `constrain` on the PAC's RCC peripheral.
///
/// ```rust
/// let dp = stm32::Peripherals::take().unwrap();
/// let rcc = dp.RCC.constrain();
/// ```
pub struct Rcc {
    config: Config,
    pub(crate) rb: RCC,
}

/// Core Clock Distribution and Reset (CCDR)
pub struct Ccdr {
    /// A record of the frozen core clock frequencies
    pub clocks: CoreClocks,

    /// Peripheral reset / enable / kernel clock control
    pub peripheral: PeripheralREC,

    // Yes, it lives (locally)! We retain the right to switch most
    // PKSUs on the fly, to fine-tune PLL frequencies, and to enable /
    // reset peripherals.
    //
    // TODO: Remove this once all permitted RCC register accesses
    // after freeze are enumerated in this struct
    pub(crate) rb: RCC,
}

const HSI: u32 = 8_000_000; // Hz
const LSI: u32 = 32_000; // Hz

impl Rcc {
    /// Uses HSE (external oscillator) instead of HSI (internal RC
    /// oscillator) as the clock source. Will result in a hang if an
    /// external oscillator is not connected or it fails to start.
    #[must_use]
    pub fn use_hse(mut self, freq: Hertz) -> Self {
        self.config.hse = Some(freq.raw());
        self
    }

    /// Use an external clock signal rather than a crystal oscillator,
    /// bypassing the XTAL driver.
    #[must_use]
    pub fn bypass_hse(mut self) -> Self {
        self.config.bypass_hse = true;
        self
    }

    /// Set input frequency of system clock
    #[must_use]
    pub fn sysclk(mut self, freq: Hertz) -> Self {
        self.config.sysclk = Some(freq.raw());
        self
    }

    /// Set the peripheral clock frequency for AHB peripherals.
    #[must_use]
    pub fn hclk(mut self, freq: Hertz) -> Self {
        self.config.rcc_hclk = Some(freq.raw());
        self
    }

    /// Set the peripheral clock frequency for APB1 peripherals.
    /// USART[2-3], UART[4-8], SPI[2-3], I2C[1-2], USBD, TIM[2-5]
    #[must_use]
    pub fn pclk1(mut self, freq: Hertz) -> Self {
        self.config.rcc_pclk1 = Some(freq.raw());
        self
    }

    /// Set the peripheral clock frequency for APB2 peripherals.
    /// GPIOx, USART1, SPI1, TIM1, TIM[9-10]
    #[must_use]
    pub fn pclk2(mut self, freq: Hertz) -> Self {
        self.config.rcc_pclk2 = Some(freq.raw());
        self
    }

    /// Reset sysclk, use HSI
    fn sysclk_reset(&mut self) {
        let rcc = &self.rb;
        rcc.ctlr.modify(|_, w| {
            // TODO: pll2 pll3
            w.pllon()
                .clear_bit()
                .hsebyp()
                .clear_bit()
                .hseon()
                .clear_bit()
                .hsion()
                .set_bit()
                .pll2on()
                .clear_bit()
                .pll3on()
                .clear_bit()
        });
        while rcc.ctlr.read().hsirdy().bit_is_clear() {} // wait for HSI ready
        rcc.cfgr0.modify(|_, w| unsafe { w.sw().bits(0b00) });
        unsafe {
            (*EXTEND::ptr())
                .extend_ctr
                .modify(|_, w| w.pll_hsi_pre().set_bit())
        }
        while rcc.cfgr0.read().sws().bits() != 0b00 {}
    }

    /// Setup sysclk, (sysclk, pllclk)
    fn sysclk_setup(&mut self) -> (Hertz, Option<Hertz>) {
        // Compare available with wanted clocks
        let srcclk = self.config.hse.unwrap_or(HSI);
        let sysclk = self.config.sysclk.unwrap_or(srcclk);

        let use_hse = self.config.hse.is_some();

        self.sysclk_reset();

        if use_hse {
            let (sw, pllmul, pllsrc, prediv1, prediv1src) = sysclk_via_hse(srcclk, sysclk);

            if self.config.bypass_hse {
                self.rb.ctlr.modify(|_, w| w.hsebyp().set_bit());
            }
            self.rb.ctlr.modify(|_, w| w.hseon().set_bit());
            while self.rb.ctlr.read().hserdy().bit_is_clear() {} // wait for HSE ready

            self.rb.cfgr2.modify(|_, w| unsafe {
                w.prediv1src().bit(prediv1src != 0).prediv1().bits(prediv1)
            });
            self.rb.cfgr0.modify(|_, w| unsafe {
                w.pllsrc()
                    .bit(pllsrc != 0)
                    .pllmul()
                    .bits(pllmul)
                    .sw()
                    .bits(sw)
            });

            // PLL on
            if sw == 0b10 {
                self.rb.ctlr.modify(|_, w| w.pllon().set_bit());
            }

            while self.rb.cfgr0.read().sws().bits() != sw {}

            if sw == 0b01 {
                // HSE
                (Hertz::from_raw(sysclk), None)
            } else if sw == 0b10 {
                // PLL
                (Hertz::from_raw(sysclk), Some(Hertz::from_raw(sysclk)))
            } else {
                unreachable!()
            }
        } else {
            let (sw, pllmul, pllsrc, hsipre) = sysclk_via_hsi(sysclk);

            unsafe {
                (*EXTEND::ptr())
                    .extend_ctr
                    .modify(|_, w| w.pll_hsi_pre().bit(hsipre != 0))
            }
            self.rb.cfgr0.modify(|_, w| unsafe {
                w.pllsrc()
                    .bit(pllsrc != 0)
                    .pllmul()
                    .bits(pllmul)
                    .sw()
                    .bits(sw)
            });
            if sw == 0b10 {
                self.rb.ctlr.modify(|_, w| w.pllon().set_bit());
            }

            while self.rb.cfgr0.read().sws().bits() != sw {}

            if sw == 0b00 {
                // HSI
                (Hertz::from_raw(sysclk), None)
            } else if sw == 0b10 {
                // PLL
                (Hertz::from_raw(sysclk), Some(Hertz::from_raw(sysclk)))
            } else {
                unreachable!()
            }
        }
    }

    pub fn freeze(mut self) -> Ccdr {
        let (sysclk, pllclk) = self.sysclk_setup();

        // HCLK defaults to SYSCLK
        let hclk = self.config.rcc_hclk.unwrap_or(sysclk.raw());
        let mut hclk_satisfied = false;
        if hclk != sysclk.raw() {
            for (hpre, div) in (0b0111..=0b1111).zip([1, 2, 4, 8, 16, 64, 128, 256, 512]) {
                if sysclk.raw() / div == hclk {
                    self.rb.cfgr0.modify(|_, w| unsafe { w.hpre().bits(hpre) });
                    hclk_satisfied = true;
                    break;
                }
            }
            if !hclk_satisfied {
                panic!("hclk not satisfied");
            }
        }
        let hclk = Hertz::from_raw(hclk);

        let pclk1 = self.config.rcc_pclk1.unwrap_or(hclk.raw());
        let mut pclk1_satisfied = false;
        if pclk1 != hclk.raw() {
            for (ppre1, div) in (0b011..=0b111).zip([1, 2, 4, 8, 16]) {
                if hclk.raw() / div == pclk1 {
                    self.rb
                        .cfgr0
                        .modify(|_, w| unsafe { w.ppre1().bits(ppre1) });
                    pclk1_satisfied = true;
                    break;
                }
            }
            if !pclk1_satisfied {
                panic!("pclk1 not satisfied");
            }
        }

        let pclk2 = self.config.rcc_pclk2.unwrap_or(hclk.raw());
        let mut pclk2_satisfied = false;
        if pclk2 != hclk.raw() {
            for (ppre2, div) in (0b011..=0b111).zip([1, 2, 4, 8, 16]) {
                if hclk.raw() / div == pclk2 {
                    self.rb
                        .cfgr0
                        .modify(|_, w| unsafe { w.ppre2().bits(ppre2) });
                    pclk2_satisfied = true;
                    break;
                }
            }
            if !pclk2_satisfied {
                panic!("pclk2 not satisfied");
            }
        }

        Ccdr {
            clocks: CoreClocks {
                sysclk: sysclk,
                hclk: hclk,
                pclk1: Hertz::from_raw(pclk1),
                pclk2: Hertz::from_raw(pclk2),
                pllclk: pllclk,
                pll2clk: None,
                pll3clk: None,
            },
            peripheral: unsafe { PeripheralREC::new_singleton() },
            rb: self.rb,
        }
    }
}

/// Setters for Micro-Controller Out (MCO)
impl Rcc {
    /// Set the MCO output frequency. The clock is sourced from the HSE
    pub fn mco_from_hse(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the HSI
    pub fn mco_from_hsi(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the SYSCLK
    pub fn mco_from_sysclk(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the PLLCLK/2
    pub fn mco_from_pllclk_div2(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the PLL2CLK
    pub fn mco_from_pll2clk(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the PLL3CLK/2
    pub fn mco_from_pll3clk_div2(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the PLL3CLK
    pub fn mco_from_pll3clk(mut self) -> Self {
        unimplemented!()
    }

    /// Set the MCO output frequency. The clock is sourced from the XTI
    pub fn mco_from_xti(mut self) -> Self {
        unimplemented!()
    }
}

/// Frozen core clock frequencies
///
/// The existence of this value indicates that the core clock
/// configuration can no longer be changed
#[derive(Clone, Copy)]
pub struct CoreClocks {
    /// system clock
    pub sysclk: Hertz,
    /// AHB
    pub hclk: Hertz,
    /// APB1
    pub pclk1: Hertz,
    /// APB2
    pub pclk2: Hertz,

    // pll or not
    pub pllclk: Option<Hertz>,
    pub pll2clk: Option<Hertz>,
    pub pll3clk: Option<Hertz>,
}

// sws: sys clock select
// (sw, pllmul, pllsrc, hsipre)
// NOTE: for D8C
fn sysclk_via_hsi(sysclk: u32) -> (u8, u8, u8, u8) {
    let mut sw = 0b00; // SYSCLK = HSI
    let mut pllmul = 0b0000;
    let pllsrc = 0b0; // HSI clock not divided or divided by 2
    let mut hsipre = 0b1; // HSI as PLL input
    if sysclk != HSI {
        sw = 0b10; // SYSCLK = PLL

        // 2nd 6 is fake, never reached
        const PLLMUL: [u32; 16] = [18, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 6, 15, 16];
        for (i, m) in PLLMUL.iter().enumerate() {
            if HSI * m == sysclk {
                pllmul = i as u8;
                return (sw, pllmul, pllsrc, hsipre);
            }
            if HSI / 2 * m == sysclk {
                pllmul = i as u8;
                hsipre = 0b0; // HSI/2 as PLL input
                return (sw, pllmul, pllsrc, hsipre);
            }
        }
        if HSI * 13 / 2 == sysclk {
            pllmul = 0b1101; // PLL input x 6.5
            return (sw, pllmul, pllsrc, hsipre);
        }
        if HSI * 13 / 4 == sysclk {
            pllmul = 0b1101;
            hsipre = 0b0; // HSI/2 as PLL input
            return (sw, pllmul, pllsrc, hsipre);
        }
        panic!("cannot satisfy sysclk");
    }
    return (sw, pllmul, pllsrc, hsipre);
}

// (sw, pllmul, pllsrc, prediv1, prediv1src)
// NOTE: for D8C
fn sysclk_via_hse(hse: u32, sysclk: u32) -> (u8, u8, u8, u8, u8) {
    let mut sw = 0b01; // HSE as SYSCLK
    let mut pllmul = 0b0000;
    let pllsrc = 0b1; // HSE clock not divided or divided by 2;
    let prediv1 = 0b0000;
    let prediv1src = 0b0; // HSE as PREDIV1 input

    if hse != sysclk {
        sw = 0b10; // SYSCLK = PLL

        // 2nd 6 is fake, never reached
        const PLLMUL: [u32; 16] = [18, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 6, 15, 16];
        for (i, m) in PLLMUL.iter().enumerate() {
            if hse * m == sysclk {
                pllmul = i as u8;
                return (sw, pllmul, pllsrc, prediv1, prediv1src);
            }
        }
        if hse * 13 / 2 == sysclk {
            pllmul = 0b1101; // PLL input x 6.5
            return (sw, pllmul, pllsrc, prediv1, prediv1src);
        }
        panic!("cannot satisfy sysclk");
    }
    return (sw, pllmul, pllsrc, prediv1, prediv1src);
}

// TODO
fn sysclk_via_pll2() {}
